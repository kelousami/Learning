
Git is a distributed (source) version control system.
Distributed, in the sense there is no need to central repository like we have
with SVN and CVS.

It was created by Linus Torvalds and currently maintained by Junio Hamano.

Limitations of CVCS (Centralized Version Control Systems)
    > Single point of failure

In Git, every clone is a full backup of all the data (of the project).

The local repository consists of 3 trees maintained by git:
    1. Working Directory
        > Holds actual files.

    2. Index
        > Acts as staging area.

    3. HEAD
        > Points to last commit made.


Branching
---------
    Branches are used to develop features isolated from each other. 
    The "master" branch is the "default" branch when we create a repository.
    We use branches for development and we merge them back to the master branch
    upon completion.
    
    There should be only one rule regarding branches:
        ANYTHING IN THE MASTER BRANCH IS ALWAYS DEPLOYABLE
    
    Then, merging a branch back to master, should be done some time after branch
    code is deployed and verfied in production. This gives a chance, in case of
    problem due to the new branch to just deploy master on production again.


Git configuration:
------------------
> In order to show actual config
    $ git config --list
    [output]
    user.name=Khalid Elousami
    user.email=elousami_khalid@hotmail.com
    mergetool.keepbackup=false
    core.repositoryformatversion=0
    core.filemode=true
    core.bare=false
    core.logallrefupdates=true
    remote.github.repository.url=git@github.com:kelousami/typical-arch-1.git
    remote.github.repository.fetch=+refs/heads/*:refs/remotes/github.repository/*
    merge.tool=meld

Main operations:
----------------
(Thanks go to Roger Dudler http://rogerdudler.github.io/git-guide/ )

> In order to create a new repository, in the project root folder
    $ git init

> In order to checkout a repositoy
    > from local repository
        $ git clone /path/to/repository

    > from remote server
        $ git clone username@host:/path/to/repository

> In order to propose changes (add it to the Index)
    $ git add <filename>
    or
    $ git add *

> In order to undo add, use git reset
    $ git reset <filename>

> In order to (actually) commit the change:
    $ git commit -m "Commit message"
    
    This will commit the file to  the HEAD (in local repository), but not yet 
    in the remote repository.

> In order to send changes to remote repository, into "master" branch
    $ git push origin master

    Origin is an alias to remote repository. It's automatically named by git 
    after a clone. We can also do
    $ git push git@github.com:git/git.git master

    If the remote repository hasn't been cloned before, we need first to add it
    $ git remote add origin <remote_server>
    $ git remote add github.repository git@github.com:kelousami/Learning.git

> In order to see remote repositories
    $ git remote show
    $ git remote -v

> In order to rename the alias "origin" 
    $ git remote rename origin github.repository

> In order to remove declared remote locally
    $ git remote rm github.repository

> In order to see details of a remote (alias=origin)
    $ git remote show origin

> In order to update local repository (with changes from remote branch "master")
    $ git pull origin master

> In order to set a merge tool
    $ git config merge.tool meld

> In order to use the configured merge tool (only opened when there is conflict)
    $ git mergetool

> In order to delete .orig files generated by merge tools to save conflict
tracks
    $ git config --global mergetool.keepBackup false

> In order to create a branch named "feature_x" and switch to it
    $ git checkout -b feature_x

> In order to switch back to master
    $ git checkout master

> In order to compare to branches 
    $ git diff master..feature_x

> In order to merge branch "feature_x" to master (after checkout master)
    $ git merge feature_x

    This is an ff merge, say fast-forward
    The problem with it, is when you see history of master, you won't be able 
    to visualize that some changes have been done on "feature_x" branch. 
    Everything will look like if it was done under the master.

    To prevent this, use --no-ff
    $ git merge --no-ff feature_x

> In order to see which branches have not yet been merged into the current one
    $ git branch --no-merged

> In order to delete a local branch
    $ git branch -d feature_x

> In order to delete a remote branch 
    $ git push origin --delete feature_x

> In order to rename a branch
    $ git branch -m v1.0.0 develop

> In order to show branches (local on remote)
    $ git branch -a

    and only remote
    $ git branch -r

    and only local
    $ git branch

> To make the branch available to others, push it to remote repository
    $ git push origin feature_x

> To create tag, in order to release a version, let's say 1.0.0
    $ git tag 1.0.0 1b2e1d63ff
    "1b2e1d63ff" are 10 first characters of the commit id, which may be
    obtained from log.

> To see log, track of last changes
    $ git log
    $ git log --author=Khalid
    $ git log --pretty=oneline

> To see ASCII art tree of all branches, decorated with the names of tags and
branches 
    $ git log --graph --oneline --decorate --all

> To see only which files have changed
    $ git log --name-status

> In case of problem (missing up with local files) and we need to replace local
changes with last from HEAD
    $ git checkout -- <filename>

> In order to drop all local changes and commits, fetch the latest history from
the server and point local master branch at it 
    $ git fetch origin
    $ git reset --hard origin/master

> In order to 'checkout' a remote tag, first bring all tags and remotes
    $ git fetch --all --tags --prune
  Then check out the tag by running
    $ git checkout tags/<tag_name> -b <branch_name>

> In order to find a lost local commited changes do the following 
  First diplay changes made locally 
    $  git reflog
  Then reset a change 
    $ git reset -- hard 89a4780

> Once a repo has been forked, in order to keep the forked updated, here are the steps:
  First, add a new remote to the original repo 
    $ git remote -v
    $ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git
  Then, fetch the upstream
    $ git fetch upstream
  Then move to the desired branch, here master
    $ git checkout master
  Then merge from upstream 
    $ git merge upstream/master
  Finally the local repo can be pushed to remote
    $ git push origin master

> In order to rebase develop to master, assuming on develop branch 
    $ git rebase --no-ff master
  Then, as the remote origin/develop will be no more of interest, we just force it to take the local one 
    $ git push --force origin develop










